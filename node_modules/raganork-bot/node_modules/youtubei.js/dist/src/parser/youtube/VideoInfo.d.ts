import { ParsedResponse } from '../index';
import VideoPrimaryInfo from '../classes/VideoPrimaryInfo';
import VideoSecondaryInfo from '../classes/VideoSecondaryInfo';
import MerchandiseShelf from '../classes/MerchandiseShelf';
import ChipCloud from '../classes/ChipCloud';
import ChipCloudChip from '../classes/ChipCloudChip';
import CommentsEntryPointHeader from '../classes/comments/CommentsEntryPointHeader';
import LiveChat from '../classes/LiveChat';
import PlayerOverlay from '../classes/PlayerOverlay';
import LiveChatWrap from './LiveChat';
import type CardCollection from '../classes/CardCollection';
import type Endscreen from '../classes/Endscreen';
import type Format from '../classes/misc/Format';
import type PlayerAnnotationsExpanded from '../classes/PlayerAnnotationsExpanded';
import type PlayerCaptionsTracklist from '../classes/PlayerCaptionsTracklist';
import type PlayerLiveStoryboardSpec from '../classes/PlayerLiveStoryboardSpec';
import type PlayerStoryboardSpec from '../classes/PlayerStoryboardSpec';
import type Player from '../../core/Player';
import type Actions from '../../core/Actions';
import type { ApiResponse } from '../../core/Actions';
import type { ObservedArray, YTNode } from '../helpers';
export type URLTransformer = (url: URL) => URL;
export interface FormatOptions {
    /**
     * Video quality; 360p, 720p, 1080p, etc... also accepts 'best' and 'bestefficiency'.
     */
    quality?: string;
    /**
     * Download type, can be: video, audio or video+audio
     */
    type?: 'video' | 'audio' | 'video+audio';
    /**
     * File format, use 'any' to download any format
     */
    format?: string;
    /**
     * InnerTube client, can be ANDROID, WEB, YTMUSIC, YTMUSIC_ANDROID, YTSTUDIO_ANDROID or TV_EMBEDDED
     */
    client?: 'WEB' | 'ANDROID' | 'YTMUSIC_ANDROID' | 'YTMUSIC' | 'YTSTUDIO_ANDROID' | 'TV_EMBEDDED';
}
export interface DownloadOptions extends FormatOptions {
    /**
     * Download range, indicates which bytes should be downloaded.
     */
    range?: {
        start: number;
        end: number;
    };
}
declare class VideoInfo {
    #private;
    basic_info: {
        like_count: number | undefined;
        is_liked: boolean | undefined;
        is_disliked: boolean | undefined;
        embed: {
            iframe_url: string;
            flash_url: string;
            flash_secure_url: string;
            width: any;
            height: any;
        } | null;
        channel: {
            id: string;
            name: string;
            url: string;
        } | null;
        is_unlisted: boolean | undefined;
        is_family_safe: boolean | undefined;
        has_ypc_metadata: boolean | null;
        start_timestamp: Date | null;
        id?: string | undefined;
        channel_id?: string | undefined;
        title?: string | undefined;
        duration?: number | undefined;
        keywords?: string[] | undefined;
        is_owner_viewing?: boolean | undefined;
        short_description?: string | undefined;
        thumbnail?: import("../classes/misc/Thumbnail").default[] | undefined;
        allow_ratings?: boolean | undefined;
        view_count?: number | undefined;
        author?: string | undefined;
        is_private?: boolean | undefined;
        is_live?: boolean | undefined;
        is_live_content?: boolean | undefined;
        is_upcoming?: boolean | undefined;
        is_crawlable?: boolean | undefined;
    };
    streaming_data: {
        expires: Date;
        formats: Format[];
        adaptive_formats: Format[];
        dash_manifest_url: string | null;
        hls_manifest_url: string | null;
    } | undefined;
    playability_status: {
        status: string;
        error_screen: YTNode | null;
        audio_only_playablility: import("../classes/AudioOnlyPlayability").default | null;
        embeddable: boolean;
        reason: any;
    } | undefined;
    annotations: ObservedArray<PlayerAnnotationsExpanded>;
    storyboards: PlayerStoryboardSpec | PlayerLiveStoryboardSpec | null;
    endscreen: Endscreen | null;
    captions: PlayerCaptionsTracklist | null;
    cards: CardCollection | null;
    primary_info?: VideoPrimaryInfo | null;
    secondary_info?: VideoSecondaryInfo | null;
    merchandise?: MerchandiseShelf | null;
    related_chip_cloud?: ChipCloud | null;
    watch_next_feed?: ObservedArray<YTNode> | null;
    player_overlays?: PlayerOverlay | null;
    comments_entry_point_header?: CommentsEntryPointHeader | null;
    livechat?: LiveChat | null;
    /**
     * @param data - API response.
     * @param actions - Actions instance.
     * @param player - Player instance.
     * @param cpn - Client Playback Nonce.
     */
    constructor(data: [ApiResponse, ApiResponse?], actions: Actions, player?: Player, cpn?: string);
    /**
     * Applies given filter to the watch next feed. Use {@link filters} to get available filters.
     * @param target_filter - Filter to apply.
     */
    selectFilter(target_filter: string | ChipCloudChip | undefined): Promise<VideoInfo>;
    /**
     * Adds video to the watch history.
     */
    addToWatchHistory(): Promise<Response>;
    /**
     * Retrieves watch next feed continuation.
     */
    getWatchNextContinuation(): Promise<VideoInfo>;
    /**
     * Likes the video.
     */
    like(): Promise<ApiResponse>;
    /**
     * Dislikes the video.
     */
    dislike(): Promise<ApiResponse>;
    /**
     * Removes like/dislike.
     */
    removeRating(): Promise<ApiResponse>;
    /**
     * Retrieves Live Chat if available.
     */
    getLiveChat(): LiveChatWrap;
    /**
     * Watch next feed filters.
     */
    get filters(): string[];
    /**
     * Actions instance.
     */
    get actions(): Actions;
    /**
     * Content Playback Nonce.
     */
    get cpn(): string | undefined;
    /**
   * Checks if continuation is available for the watch next feed.
   */
    get wn_has_continuation(): boolean;
    /**
     * Original parsed InnerTube response.
     */
    get page(): [ParsedResponse, ParsedResponse?];
    /**
     * Get songs used in the video.
     */
    get music_tracks(): never[];
    /**
     * Selects the format that best matches the given options.
     * @param options - Options
     */
    chooseFormat(options: FormatOptions): Format;
    /**
     * Generates a DASH manifest from the streaming data.
     * @param url_transformer - Function to transform the URLs.
     * @returns DASH manifest
     */
    toDash(url_transformer?: URLTransformer): string;
    /**
     * Downloads the video.
     * @param options - Download options.
     */
    download(options?: DownloadOptions): Promise<ReadableStream<Uint8Array>>;
}
export default VideoInfo;

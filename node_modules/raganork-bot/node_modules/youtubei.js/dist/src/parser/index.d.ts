import type AudioOnlyPlayability from './classes/AudioOnlyPlayability';
import type CardCollection from './classes/CardCollection';
import type Endscreen from './classes/Endscreen';
import type PlayerAnnotationsExpanded from './classes/PlayerAnnotationsExpanded';
import type PlayerCaptionsTracklist from './classes/PlayerCaptionsTracklist';
import type PlayerLiveStoryboardSpec from './classes/PlayerLiveStoryboardSpec';
import type PlayerStoryboardSpec from './classes/PlayerStoryboardSpec';
import type Message from './classes/Message';
import type LiveChatParticipantsList from './classes/LiveChatParticipantsList';
import type LiveChatHeader from './classes/LiveChatHeader';
import type LiveChatItemList from './classes/LiveChatItemList';
import Format from './classes/misc/Format';
import VideoDetails from './classes/misc/VideoDetails';
import NavigationEndpoint from './classes/NavigationEndpoint';
import Thumbnail from './classes/misc/Thumbnail';
import { Memo, ObservedArray, SuperParsedResult, YTNode, YTNodeConstructor } from './helpers';
export type ParserError = {
    classname: string;
    classdata: any;
    err: any;
};
export type ParserErrorHandler = (error: ParserError) => void;
export default class Parser {
    #private;
    static setParserErrorHandler(handler: ParserErrorHandler): void;
    /**
     * Parses InnerTube response.
     * @param data - The response data.
     */
    static parseResponse(data: any): {
        actions: SuperParsedResult<YTNode> | null;
        actions_memo: Memo;
        contents: SuperParsedResult<YTNode>;
        contents_memo: Memo;
        header: SuperParsedResult<YTNode> | null;
        header_memo: Memo;
        sidebar: YTNode | null;
        sidebar_memo: Memo;
        live_chat_item_context_menu_supported_renderers: YTNode | null;
        live_chat_item_context_menu_supported_renderers_memo: Memo;
        on_response_received_actions: ObservedArray<ReloadContinuationItemsCommand | AppendContinuationItemsAction> | null;
        on_response_received_actions_memo: Memo;
        on_response_received_endpoints: ObservedArray<ReloadContinuationItemsCommand | AppendContinuationItemsAction> | null;
        on_response_received_endpoints_memo: Memo;
        on_response_received_commands: ObservedArray<ReloadContinuationItemsCommand | AppendContinuationItemsAction> | null;
        on_response_received_commands_memo: Memo;
        continuation: TimedContinuation | null | undefined;
        continuation_contents: SectionListContinuation | LiveChatContinuation | MusicPlaylistShelfContinuation | MusicShelfContinuation | GridContinuation | PlaylistPanelContinuation | null | undefined;
        continuation_contents_memo: Memo;
        metadata: SuperParsedResult<YTNode>;
        microformat: YTNode | null;
        overlay: YTNode | null;
        refinements: any;
        estimated_results: number | null;
        player_overlays: SuperParsedResult<YTNode>;
        playback_tracking: {
            videostats_watchtime_url: string;
            videostats_playback_url: string;
        } | null;
        playability_status: {
            status: string;
            error_screen: YTNode | null;
            audio_only_playablility: AudioOnlyPlayability | null;
            embeddable: boolean;
            reason: any;
        } | undefined;
        streaming_data: {
            expires: Date;
            formats: Format[];
            adaptive_formats: Format[];
            dash_manifest_url: string | null;
            hls_manifest_url: string | null;
        } | undefined;
        current_video_endpoint: NavigationEndpoint | null;
        endpoint: NavigationEndpoint | null;
        captions: PlayerCaptionsTracklist | null;
        video_details: VideoDetails | undefined;
        annotations: ObservedArray<PlayerAnnotationsExpanded>;
        storyboards: PlayerStoryboardSpec | PlayerLiveStoryboardSpec | null;
        endscreen: Endscreen | null;
        cards: CardCollection | null;
    };
    /**
     * Parses a single item.
     * @param data - The data to parse.
     * @param validTypes - YTNode types that are allowed to be parsed.
     */
    static parseItem<T extends YTNode = YTNode>(data: any, validTypes?: YTNodeConstructor<T> | YTNodeConstructor<T>[]): T | null;
    /**
     * Parses an array of items.
     * @param data - The data to parse.
     * @param validTypes - YTNode types that are allowed to be parsed.
     */
    static parseArray<T extends YTNode = YTNode>(data: any[], validTypes?: YTNodeConstructor<T> | YTNodeConstructor<T>[]): ObservedArray<T>;
    /**
     * Parses an item or an array of items.
     * @param data - The data to parse.
     * @param requireArray - Whether the data should be parsed as an array.
     * @param validTypes - YTNode types that are allowed to be parsed.
     */
    static parse<T extends YTNode = YTNode>(data: any, requireArray: true, validTypes?: YTNodeConstructor<T> | YTNodeConstructor<T>[]): ObservedArray<T> | null;
    static parse<T extends YTNode = YTNode>(data: any, requireArray?: false | undefined, validTypes?: YTNodeConstructor<T> | YTNodeConstructor<T>[]): SuperParsedResult<T>;
    static parseC(data: any): TimedContinuation | undefined;
    static parseLC(data: any): SectionListContinuation | LiveChatContinuation | MusicPlaylistShelfContinuation | MusicShelfContinuation | GridContinuation | PlaylistPanelContinuation | undefined;
    static parseRR(actions: any[]): ObservedArray<ReloadContinuationItemsCommand | AppendContinuationItemsAction>;
    static parseActions(data: any): SuperParsedResult<YTNode>;
    static parseFormats(formats: any[]): Format[];
    static applyMutations(memo: Memo, mutations: Array<any>): void;
    static sanitizeClassName(input: string): string;
    static ignore_list: Set<string>;
    static shouldIgnore(classname: string): boolean;
}
export type ParsedResponse = ReturnType<typeof Parser.parseResponse>;
export declare class AppendContinuationItemsAction extends YTNode {
    static readonly type = "appendContinuationItemsAction";
    contents: ObservedArray<YTNode> | null;
    constructor(data: any);
}
export declare class ReloadContinuationItemsCommand extends YTNode {
    static readonly type = "reloadContinuationItemsCommand";
    target_id: string;
    contents: ObservedArray<YTNode> | null;
    slot?: string;
    constructor(data: any);
}
export declare class SectionListContinuation extends YTNode {
    static readonly type = "sectionListContinuation";
    continuation: string;
    contents: ObservedArray<YTNode> | null;
    constructor(data: any);
}
export declare class MusicPlaylistShelfContinuation extends YTNode {
    static readonly type = "musicPlaylistShelfContinuation";
    continuation: string;
    contents: ObservedArray<YTNode> | null;
    constructor(data: any);
}
export declare class MusicShelfContinuation extends YTNode {
    static readonly type = "musicShelfContinuation";
    continuation: string;
    contents: ObservedArray<YTNode> | null;
    constructor(data: any);
}
export declare class GridContinuation extends YTNode {
    static readonly type = "gridContinuation";
    continuation: string;
    items: ObservedArray<YTNode> | null;
    constructor(data: any);
    get contents(): ObservedArray<YTNode> | null;
}
export declare class PlaylistPanelContinuation extends YTNode {
    static readonly type = "playlistPanelContinuation";
    continuation: string;
    contents: ObservedArray<YTNode> | null;
    constructor(data: any);
}
export declare class TimedContinuation extends YTNode {
    static readonly type = "timedContinuationData";
    timeout_ms: number;
    token: string;
    constructor(data: any);
}
export declare class LiveChatContinuation extends YTNode {
    static readonly type = "liveChatContinuation";
    actions: ObservedArray<YTNode>;
    action_panel: YTNode | null;
    item_list: LiveChatItemList | null;
    header: LiveChatHeader | null;
    participants_list: LiveChatParticipantsList | null;
    popout_message: Message | null;
    emojis: {
        emoji_id: string;
        shortcuts: string[];
        search_terms: string[];
        image: Thumbnail[];
    }[];
    continuation: TimedContinuation;
    viewer_name: string;
    constructor(data: any);
}
